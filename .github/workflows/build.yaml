name: Build Docker Container & Push to Registry

on:
  workflow_call:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test_fastapi_job:
    uses: StarmoonAI/starmoon-private/.github/workflows/test-fastapi.yaml@main
  docker_build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend
    needs: [test_fastapi_job]
    env:
      CLUSTER_NAME: AItoyK8s

    steps:
      - name: Checkout source code
        uses: actions/checkout@v3
      - name: Azure login
        id: login
        uses: azure/login@v1.4.3
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Azure Container Registry login
        run: |
          az acr login --name ${{ secrets.REGISTRY }}
      - name: Set AKS context
        id: set-context
        uses: azure/aks-set-context@v3
        with:
          resource-group: "${{ secrets.resource_group }}"
          cluster-name: "${{ secrets.cluster_name }}"
      - name: Build container image
        run: |
          docker build --tag aitoy:latest .
      - name: Manually tag the built image with custom tags
        run: |
          docker tag aitoy:latest aitoyregistry.azurecr.io/aitoy:${GITHUB_SHA::7}-${GITHUB_RUN_ID::5}
      - name: Push all tagged images to the registry
        run: |
          docker push aitoyregistry.azurecr.io/aitoy --all-tags
      - name: Update deployment secrets
        run: |
          if kubectl get secrets | grep -q fastapi-prod-env; then
          kubectl delete secret fastapi-prod-env
          fi
          cat << EOF >> ./.env.prod
          LLM_MODEL_NAME=${{ secrets.LLM_MODEL_NAME }}
          MS_SPEECH_ENDPOINTY=${{ secrets.MS_SPEECH_ENDPOINTY }}
          SPEECH_KEY=${{ secrets.SPEECH_KEY }}
          SPEECH_REGION=${{ secrets.SPEECH_REGION }}
          DG_API_KEY=${{ secrets.DG_API_KEY }}
          HF_ACCESS_TOKEN=${{ secrets.HF_ACCESS_TOKEN }}
          HF_EMOTION_API_URL=${{ secrets.HF_EMOTION_API_URL }}
          AZURE_OPENAI_ENDPOINT=${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_API_KEY=${{ secrets.AZURE_OPENAI_API_KEY }}
          NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          CELERY_BROKER_URL=${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND=${{ secrets.CELERY_RESULT_BACKEND }}
          CELERY_FLOWER_USER=${{ secrets.CELERY_FLOWER_USER }}
          CELERY_FLOWER_PASSWORD=${{ secrets.CELERY_FLOWER_PASSWORD }}
          EOF
          kubectl create secret generic fastapi-prod-env --from-env-file=./.env.prod
      - name: Refresh k8s deployment
        run: |
          kubectl apply -f kubernetes/redis/deployment.yaml
          kubectl apply -f kubernetes/fastapi/deployment.yaml
          kubectl apply -f kubernetes/celery/beat-deployment.yaml
          kubectl apply -f kubernetes/celery/worker-deployment.yaml
          kubectl apply -f kubernetes/flower/deployment.yaml
      - name: Update Deployment image
        run: |
          kubectl set image deployment/starmoon-app starmoon-app=aitoyregistry.azurecr.io/aitoy:${GITHUB_SHA::7}-${GITHUB_RUN_ID::5}
          kubectl set image deployment/celery-beat celery-beat=aitoyregistry.azurecr.io/aitoy:${GITHUB_SHA::7}-${GITHUB_RUN_ID::5}
          kubectl set image deployment/celery-worker celery-worker=aitoyregistry.azurecr.io/aitoy:${GITHUB_SHA::7}-${GITHUB_RUN_ID::5}
          kubectl set image deployment/celery-flower celery-flower=aitoyregistry.azurecr.io/aitoy:${GITHUB_SHA::7}-${GITHUB_RUN_ID::5}
      - name: Get Deployment status
        run: |
          kubectl rollout status deployment/starmoon-app
          kubectl rollout status deployment/celery-beat
          kubectl rollout status deployment/celery-worker
          kubectl rollout status deployment/celery-flower
      - name: Post-build FastAPI Commands - Migrate / Collectstatic
        run: |
          export SINGLE_POD_NAME=$(kubectl get pod -l app=starmoon-app -o jsonpath="{.items[0].metadata.name}")
